(load "AuxilaryFunctions.lisp")

(defvar **epsilon** .6 "The initial value for epsilon.")
(defconstant **epsilon-multiplier** 1 "The multiplier for epsilon (multiplies after each episode).")
(defconstant **alpha** .01)
(defconstant **gamma** 1)
(defconstant **lambda** .10)

(defun get-features(tilings state action)
    (unify (mapcar (lambda(tiling) (funcall (first tiling) state action)) tilings)))

(defun get-actions(world state)
    (funcall (first world) state))

(defun apply-action(world state action)
    (funcall (second world) state action))

(defun is-terminal(world state)
    (funcall (third world) state))

(defun exploration(best others)
    (if (> (random 1.0) **epsilon**)
        best
        (first (permute others))))

(defun theta-update(theta delta eligibility)
    (mapcar (lambda(theta eligibility) (+ theta (* **alpha** delta eligibility))) theta eligibility))

(defun inner-loop(world tilings state eligibility theta &aux actions A* A state-reward-tuple reward next-state delta)
    (setf actions (get-actions world state))
    (setf A* (argmax actions (lambda(action) (apply `+ (mapcar `* theta (get-features tilings state action))))))
    (setf A (exploration A* actions))
    ; (break "Actions: ~S; A*: ~S; A: ~S" actions A* A)
    (setf state-reward-tuple (apply-action world state A))
    (setf reward (first state-reward-tuple))
    (setf next-state (second state-reward-tuple))
    (setf delta (- reward (apply `+ (get-features tilings state A))))
    (unless (equal A A*)
        (setf eligibility (mapcar (lambda(elig) 0) eligibility)))

    (setf eligibility (get-features tilings state A));(mapcar `+ eligibility (get-features tilings state A)))
    (when (is-terminal world state)
        (return-from inner-loop (theta-update theta delta eligibility)))
    (let ((delta (+ delta (* **gamma** (loop for action in (get-actions world next-state) maximizing (apply `+ (get-features tilings state action)))))))
        `(,(theta-update theta delta eligibility) ,(mapcar (lambda(elig) (* **gamma** **lambda** elig)) eligibility) ,next-state)))

(defun run-episode(world state tilings theta &optional (eligibility (mapcar (lambda(elig) 0) theta)))
    (if (is-terminal world state)
        theta
        (let ((result (inner-loop world tilings state eligibility theta)))
            (run-episode world (third result) tilings (first result) (second result)))))

(compile 'run-episode)
(compile 'inner-loop)

(defun q-Learning(trials world rows cols tilings theta)
    (dotimes (n trials theta)
        (and (equal (mod n 100) 0) (print n))
        (setf theta (run-episode world `(,(random rows) ,(random cols)) tilings theta))
        (setf **epsilon** (* **epsilon** **epsilon-multiplier**))))

(defun get-policy(world n k tilings theta &aux policy row)
    (dotimes (i n (reverse policy))
        (setf row `())
        (dotimes (j k)
            (setf row (cons `((,i ,j) ,(argmax (get-actions world `(,i ,j)) (lambda(action) (apply `+ (mapcar `* theta (get-features tilings `(,i ,j) action)))))) row)))
        (setf policy (cons (reverse row) policy))))

(defconstant russellWorld `(,(lambda(state &aux actions)
                                (and (>= (first state)  1) (not (equal (third (funcall (fifth russellWorld) `(,(- (first state) 1) ,(second state)))) "w")) (setf actions (cons "north" actions)))
                                (and (< (first state)  2) (not (equal (third (funcall (fifth russellWorld) `(,(+ (first state) 1) ,(second state)))) "w")) (setf actions (cons "south" actions)))
                                (and (>= (second state) 1) (not (equal (third (funcall (fifth russellWorld) `(,(first state) ,(- (second state) 1)))) "w")) (setf actions (cons "west"  actions)))
                                (and (< (second state) 3) (not (equal (third (funcall (fifth russellWorld) `(,(first state) ,(+ (second state) 1)))) "w")) (setf actions (cons "east"  actions)))
                                actions)
                            ,(lambda(state action &aux new-state)
                                (cond
                                    ((equal action "north") (setf new-state `(,(- (first state) 1) ,(second state))))
                                    ((equal action "south") (setf new-state `(,(+ (first state) 1) ,(second state))))
                                    ((equal action "west")  (setf new-state `(,(first state) ,(- (second state) 1))))
                                    ((equal action "east")  (setf new-state `(,(first state) ,(+ (second state) 1))))
                                    (t (format t "Hi there. Action ~S doesn't exist" action))
                                )
                                (let* ((panel (funcall (fifth russellWorld) new-state))
                                       (reward (or (and (not (third panel)) -.04) (and (numberp (third panel)) (third panel)))))
                                `(,reward ,new-state))
                            )
                            ,(lambda(state)
                                (numberp (third (funcall (fifth russellWorld) state))))
                            (
                              ((0 0) (0 1) (0 2) (0 3 1))
                              ((1 0) (1 1 "w") (1 2) (1 3 -1))
                              ((2 0) (2 1) (2 2) (2 3))
                            )
                            ,(lambda(state &aux (row (floor (first state))) (col (floor (second state))))
                                (nth col (nth row (fourth russellWorld))))))


(defvar xOffset(random 1.0))
(defvar yOffset (random 1.0))

(defconstant russellTilings `((,(lambda(state action &aux output)
                            (dotimes (n 4 (reverse output))
                                (dotimes (k 5)
                                    (dolist (act (get-actions russellWorld `(,n ,k)))
                                        (setf output (cons (if (and (>= (first state) n) (< (first state) (+ 1 n)) (>= (second state) k) (< (second state) (+ k 1)) (or (not action) (equal action act)))
                                                                1
                                                                0) output)))))))
                            (,(lambda(state action &aux output)
                            (dotimes (n 4 (reverse output))
                                (dotimes (k 5)
                                    (dolist (act (get-actions russellWorld `(,n ,k)))
                                        (setf output (cons (if (and (>= (first state) (- n xOffset)) (< (first state) (+ 1 (- n xOffset))) (>= (second state) (- k yOffset)) (< (second state) (+ (- k yOffset) 1)) (or (not action) (equal action act)))
                                                                1
                                                                0) output)))))))))

(defconstant exercise1World `(,(lambda(state &aux actions)
                                (and (>= (first state)  1) (setf actions (cons "north" actions)))
                                (and (< (first state)  9) (setf actions (cons "south" actions)))
                                (and (>= (second state) 1) (setf actions (cons "west"  actions)))
                                (and (< (second state) 9) (setf actions (cons "east"  actions)))
                                actions)
                            ,(lambda(state action &aux new-state)
                                (cond
                                    ((equal action "north") (setf new-state `(,(- (first state) 1) ,(second state))))
                                    ((equal action "south") (setf new-state `(,(+ (first state) 1) ,(second state))))
                                    ((equal action "west")  (setf new-state `(,(first state) ,(- (second state) 1))))
                                    ((equal action "east")  (setf new-state `(,(first state) ,(+ (second state) 1))))
                                    (t (format t "Hi there. Action ~S doesn't exist" action))
                                )
                                (let* ((panel (funcall (fifth exercise1World) new-state))
                                       (reward (or (and (not (third panel)) -.04) (and (numberp (third panel)) (third panel)))))
                                `(,reward ,new-state))
                            )
                            ,(lambda(state)
                                (numberp (third (funcall (fifth exercise1World) state))))
                            (
                                ((0 0) (0 1) (0 2) (0 3) (0 4) (0 5) (0 6) (0 7) (0 8) (0 9 1))
                                ((1 0) (1 1) (1 2) (1 3) (1 4) (1 5) (1 6) (1 7) (1 8) (1 9))
                                ((2 0) (2 1) (2 2) (2 3) (2 4) (2 5) (2 6) (2 7) (2 8) (2 9))
                                ((3 0) (3 1) (3 2) (3 3) (3 4) (3 5) (3 6) (3 7) (3 8) (3 9))
                                ((4 0) (4 1) (4 2) (4 3) (4 4) (4 5) (4 6) (4 7) (4 8) (4 9))
                                ((5 0) (5 1) (5 2) (5 3) (5 4) (5 5) (5 6) (5 7) (5 8) (5 9))
                                ((6 0) (6 1) (6 2) (6 3) (6 4) (6 5) (6 6) (6 7) (6 8) (6 9))
                                ((7 0) (7 1) (7 2) (7 3) (7 4) (7 5) (7 6) (7 7) (7 8) (7 9))
                                ((8 0) (8 1) (8 2) (8 3) (8 4) (8 5) (8 6) (8 7) (8 8) (8 9))
                                ((9 0) (9 1) (9 2) (9 3) (9 4) (9 5) (9 6) (9 7) (9 8) (9 9))
                            )
                            ,(lambda(state &aux row col)
                                (dotimes (n 9)
                                    (when (>= (first state) n)
                                        (setf row n)))
                                (dotimes (k 9)
                                    (when (>= (second state) k)
                                        (setf col k)))
                                (nth col (nth row (fourth exercise1World))))))

(defconstant exercise1Tilings `((,(lambda(state action &aux output)
                            (dotimes (n 9 (reverse output))
                                (dotimes (k 9)
                                    (dolist (act (get-actions exercise1World `(,n ,k)))
                                        (setf output (cons (if (and (>= (first state) n) (< (first state) (+ 1 n)) (>= (second state) k) (< (second state) (+ k 1)) (or (not action) (equal action act)))
                                                                1
                                                                0) output)))))))
                            (,(lambda(state action &aux output)
                            (dotimes (n 9 (reverse output))
                                (dotimes (k 9)
                                    (dolist (act (get-actions exercise1World `(,n ,k)))
                                        (setf output (cons (if (and (>= (first state) (- n xOffset)) (< (first state) (+ 1 (- n xOffset))) (>= (second state) (- k yOffset)) (< (second state) (+ (- k yOffset) 1)) (or (not action) (equal action act)))
                                                                1
                                                                0) output)))))))))

(defconstant exercise2World `(,(lambda(state &aux actions)
                                (and (>= (first state)  1) (setf actions (cons "north" actions)))
                                (and (< (first state)  9) (setf actions (cons "south" actions)))
                                (and (>= (second state) 1) (setf actions (cons "west"  actions)))
                                (and (< (second state) 9) (setf actions (cons "east"  actions)))
                                actions)
                            ,(lambda(state action &aux new-state)
                                (cond
                                    ((equal action "north") (setf new-state `(,(- (first state) 1) ,(second state))))
                                    ((equal action "south") (setf new-state `(,(+ (first state) 1) ,(second state))))
                                    ((equal action "west")  (setf new-state `(,(first state) ,(- (second state) 1))))
                                    ((equal action "east")  (setf new-state `(,(first state) ,(+ (second state) 1))))
                                    (t (format t "Hi there. Action ~S doesn't exist" action))
                                )
                                (let* ((panel (funcall (fifth exercise2World) new-state))
                                       (reward (or (and (not (third panel)) -.04) (and (numberp (third panel)) (third panel)))))
                                `(,reward ,new-state))
                            )
                            ,(lambda(state)
                                (numberp (third (funcall (fifth exercise2World) state))))
                            (
                                ((0 0) (0 1) (0 2) (0 3) (0 4) (0 5) (0 6) (0 7) (0 8) (0 9))
                                ((1 0) (1 1) (1 2) (1 3) (1 4) (1 5) (1 6) (1 7) (1 8) (1 9))
                                ((2 0) (2 1) (2 2) (2 3) (2 4) (2 5) (2 6) (2 7) (2 8) (2 9))
                                ((3 0) (3 1) (3 2) (3 3) (3 4) (3 5) (3 6) (3 7) (3 8) (3 9))
                                ((4 0) (4 1) (4 2) (4 3) (4 4 1) (4 5) (4 6) (4 7) (4 8) (4 9))
                                ((5 0) (5 1) (5 2) (5 3) (5 4) (5 5) (5 6) (5 7) (5 8) (5 9))
                                ((6 0) (6 1) (6 2) (6 3) (6 4) (6 5) (6 6) (6 7) (6 8) (6 9))
                                ((7 0) (7 1) (7 2) (7 3) (7 4) (7 5) (7 6) (7 7) (7 8) (7 9))
                                ((8 0) (8 1) (8 2) (8 3) (8 4) (8 5) (8 6) (8 7) (8 8) (8 9))
                                ((9 0) (9 1) (9 2) (9 3) (9 4) (9 5) (9 6) (9 7) (9 8) (9 9))
                            )
                            ,(lambda(state &aux row col)
                                (dotimes (n 9)
                                    (when (>= (first state) n)
                                        (setf row n)))
                                (dotimes (k 9)
                                    (when (>= (second state) k)
                                        (setf col k)))
                                (nth col (nth row (fourth exercise2World))))))

(defconstant exercise2Tilings `((,(lambda(state action &aux output)
                            (dotimes (n 9 (reverse output))
                                (dotimes (k 9)
                                    (dolist (act (get-actions exercise2World `(,n ,k)))
                                        (setf output (cons (if (and (>= (first state) n) (< (first state) (+ 1 n)) (>= (second state) k) (< (second state) (+ k 1)) (or (not action) (equal action act)))
                                                                1
                                                                0) output)))))))
                            (,(lambda(state action &aux output)
                            (dotimes (n 9 (reverse output))
                                (dotimes (k 9)
                                    (dolist (act (get-actions exercise2World `(,n ,k)))
                                        (setf output (cons (if (and (>= (first state) (- n xOffset)) (< (first state) (+ 1 (- n xOffset))) (>= (second state) (- k yOffset)) (< (second state) (+ (- k yOffset) 1)) (or (not action) (equal action act)))
                                                                1
                                                                0) output)))))))))

(defconstant russellSituation `(7000 ,russellWorld 3 4 ,russellTilings ,(mapcar (lambda(activation) 0) (funcall (first (first russellTilings)) `(0 0) `NIL))))
(defconstant exercise1Situation `(3000 ,russellWorld 10 10 ,exercise1Tilings ,(mapcar (lambda(activation) 0) (funcall (first (first exercise1Tilings)) `(0 0) `NIL))))
(defconstant exercise2Situation `(3000 ,russellWorld 10 10 ,exercise2Tilings ,(mapcar (lambda(activation) 0) (funcall (first (first exercise2Tilings)) `(0 0) `NIL))))


    ; (loop until (is-terminal world state) do
    ;     (setf result ))
    ;     (setf theta (first result))
    ;     (setf eligibility (second result))
    ;     (setf state (third result))))